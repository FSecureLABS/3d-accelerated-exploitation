#include "vbox3d.h"

// DLL handle and exported methods
HMODULE hVBoxSharedCrOpenGL;
_VBoxHGCMSvcLoad				VBoxHGCMSvcLoad;
_svcCall						svcCall;
_crVBoxServerAddClient			VBoxServerAddClient;
_crVBoxServerRemoveClient		VBoxServerRemoveClient;

// a global counter for client IDs
uint32_t g_u32ClientId = 1;

// global pointer for VBoxHGCMSvcLoad
void* g_ptable = NULL;
int32_t g_rc = -1;
VBOXHGCMSVCHELPERS g_helpers;

void vbox3d::init() {
	bool bResult = false;
	
	// get module handle
	hVBoxSharedCrOpenGL = LoadLibrary(L"VBoxSharedCrOpenGL");

	if (hVBoxSharedCrOpenGL == NULL) {
		LOG_ERROR("failed to load VBoxSharedCrOpenGL! error: " + to_str(GetLastError()));
		bailout();
	}

	// get exported methods
	VBoxHGCMSvcLoad				= (_VBoxHGCMSvcLoad)GetProcAddress(hVBoxSharedCrOpenGL, "VBoxHGCMSvcLoad");
	VBoxServerAddClient			= (_crVBoxServerAddClient)GetProcAddress(hVBoxSharedCrOpenGL, "crVBoxServerAddClient");
	VBoxServerRemoveClient		= (_crVBoxServerRemoveClient)GetProcAddress(hVBoxSharedCrOpenGL, "crVBoxServerRemoveClient");

	/*	VBoxHGCMSvcLoad expects a VBOXHGCMSVCFNTABLE object. But we are not going to include
		those definitions, since we are only interested in getting the address of svcCall,
		and setting the value of g_pHelpers
		VBoxHGCMSvcLoad defined in: VBox\HostServices\SharedOpenGL\crserver\crservice.cpp
	*/
	g_ptable = malloc(VBOXHGCMSVCFNTABLE_SIZE);
	g_ptable = memset(g_ptable, 0x00, VBOXHGCMSVCFNTABLE_SIZE);

	// set size and version
	((int*)g_ptable)[0] = VBOXHGCMSVCFNTABLE_SIZE;		// cbSize
	((int*)g_ptable)[1] = VBOX_HGCM_SVC_VERSION;		// u32Version

	// we need a VBOXHGCMSVCHELPERS object for callbacks within svcCall
	g_helpers.pfnCallComplete = vbox3d::pfnCallComplete;
	g_helpers.pfnDisconnectClient = vbox3d::pfnDisconnectClient;
	((int64_t*)g_ptable)[VBOXHGCMSVCFNTABLE_PHELPERS_OFFSET / 8] = (int64_t)&g_helpers;


	// load service
	int rc = VBoxHGCMSvcLoad(g_ptable);

	if (rc != 0) { //!VBoxServerInit()
		LOG_ERROR("VBoxHGCMSvcLoad failed! rc = " + to_str(rc));
		bailout();
	}

	// if it was successful, we can get svcCall from g_ptable
	svcCall = (_svcCall)((int64_t*)g_ptable)[VBOXHGCMSVCFNTABLE_SVCCALL_OFFSET / 8];
}

void vbox3d::destroy() {
	return;
}

uint32_t vbox3d::connect() {
	uint32_t rc  = VBoxServerAddClient(g_u32ClientId);

	// rc == 0 means success
	if (rc != 0) {
		return 0;
	}

	// just set the version here
	if (hgcm_set_version(g_u32ClientId) != 0) {
		vbox3d::disconnect(g_u32ClientId);
		return 0;
	}

	return g_u32ClientId++;
}

void vbox3d::disconnect(uint32_t u32ClientId) {
	VBoxServerRemoveClient(u32ClientId);
}

int vbox3d::hgcm_write(uint32_t u32ClientId, uint8_t* pBuffer, uint32_t cbBuffer) {

	VBOXHGCMSVCPARM paParms[1];
	
	paParms[0].type = VBOX_HGCM_SVC_PARM_PTR;
	paParms[0].u.pointer.addr = pBuffer;
	paParms[0].u.pointer.size = cbBuffer;

	return vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_WRITE, SHCRGL_CPARMS_WRITE, paParms);
}

int vbox3d::hgcm_read(uint32_t u32ClientId, uint8_t* pBuffer, uint32_t cbBuffer) {
	VBOXHGCMSVCPARM paParms[1];

	paParms[0].type = VBOX_HGCM_SVC_PARM_PTR;
	paParms[0].u.pointer.addr = pBuffer;
	paParms[0].u.pointer.size = cbBuffer;

	return vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_READ, SHCRGL_CPARMS_READ, paParms);
}

uint32_t vbox3d::hgcm_write_buffer_create(uint32_t u32ClientId, uint32_t cbBufferSize, uint8_t* pBuffer, uint32_t cbBuffer) {
	uint32_t iBuffer = 0;

	VBOXHGCMSVCPARM paParms[4];

	// paParms[0] - iBuffer
	paParms[0].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[0].u.uint32 = iBuffer; // 0 will force a new allocation
	
	// paParms[1] - cbBufferSize
	paParms[1].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[1].u.uint32 = cbBufferSize;

	// paParms[2] - ui32Offset
	paParms[2].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[2].u.uint32 = 0; // since we are allocating, we copy to the start of the newly-created memory

	// paParms[3] - pBuffer/cbBuffer
	paParms[3].type = VBOX_HGCM_SVC_PARM_PTR;
	paParms[3].u.pointer.addr = pBuffer;
	paParms[3].u.pointer.size = cbBuffer;

	int rc = hgcm_call(u32ClientId, SHCRGL_GUEST_FN_WRITE_BUFFER, SHCRGL_CPARMS_WRITE_BUFFER, paParms);

	if (rc != 0) {
		return 0;
	}

	iBuffer = paParms[0].u.uint32; // the new iBuffer is written back to us

	return iBuffer;
}

uint32_t vbox3d::hgcm_write_buffer_modify(uint32_t u32ClientId, uint32_t iBuffer, uint32_t ui32Offset,
	uint32_t cbBufferSize, uint8_t* pBuffer, uint32_t cbBuffer) {

	VBOXHGCMSVCPARM paParms[4];

	// paParms[0] - iBuffer
	paParms[0].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[0].u.uint32 = iBuffer;

	// paParms[1] - cbBufferSize
	paParms[1].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[1].u.uint32 = cbBufferSize;

	// paParms[2] - ui32Offset
	paParms[2].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[2].u.uint32 = ui32Offset; // bytes into the buffer we want to start modifying

	// paParms[3] - pBuffer/cbBuffer
	paParms[3].type = VBOX_HGCM_SVC_PARM_PTR;
	paParms[3].u.pointer.addr = pBuffer;
	paParms[3].u.pointer.size = cbBuffer;

	int rc = hgcm_call(u32ClientId, SHCRGL_GUEST_FN_WRITE_BUFFER, SHCRGL_CPARMS_WRITE_BUFFER, paParms);

	if (rc != 0) {
		return 0;
	}

	iBuffer = paParms[0].u.uint32; // the new iBuffer is written back to us

	return iBuffer;
}

uint32_t vbox3d::hgcm_read_buffered(uint32_t u32ClientId, uint32_t iBuffer, uint8_t* pWriteback, uint32_t cbWriteback) {
	
	VBOXHGCMSVCPARM paParms[3];

	// paParms[0] - iBuffer
	paParms[0].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[0].u.uint32 = iBuffer;

	// paParms[1] - pWriteback/cbWriteback
	paParms[1].type = VBOX_HGCM_SVC_PARM_PTR;
	paParms[1].u.pointer.addr = pWriteback;
	paParms[1].u.pointer.size = cbWriteback;

	// paParms[2] - cbWriteback
	// written size writeback
	paParms[2].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[2].u.uint32 = 0;

	int rc = hgcm_call(u32ClientId, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, SHCRGL_CPARMS_WRITE_READ_BUFFERED, paParms);

	if (rc != 0) {
#ifdef _DEBUG
		LOG_ERROR("something went wrong");
#endif
	}

	return paParms[2].u.uint32;
}

int vbox3d::hgcm_set_version(uint32_t u32ClientId) {
	VBOXHGCMSVCPARM paParms[2];

	// vMajor
	paParms[0].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[0].u.uint32 = CR_PROTOCOL_VERSION_MAJOR;

	// vMinor
	paParms[1].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[1].u.uint32 = CR_PROTOCOL_VERSION_MINOR;

	return vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_SET_VERSION, SHCRGL_CPARMS_SET_VERSION, paParms);
}

int vbox3d::hgcm_set_pid(uint32_t u32ClientId, int64_t pid) {

	VBOXHGCMSVCPARM paParms[1];
	
	// pid
	paParms[0].type = VBOX_HGCM_SVC_PARM_64BIT;
	paParms[0].u.uint64 = pid;

	return vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_SET_PID, SHCRGL_CPARMS_SET_PID, paParms);
}

// a wrapper that just accepts the parameters that are applicable to svcCall
// the wrapper will read the global g_rc to return the response code, since we aren't
// threading anything
int vbox3d::hgcm_call(uint32_t u32ClientId, uint32_t u32Function, uint32_t cParms, VBOXHGCMSVCPARM paParms[]) {
	svcCall(NULL, 0, u32ClientId, NULL, u32Function, cParms, paParms);
	return g_rc;
}

// helpers
void vbox3d::pfnCallComplete(void*, int32_t rc) {
	g_rc = rc;
	return;
}

void vbox3d::pfnDisconnectClient(void*, uint32_t u32ClientId) {
	vbox3d::disconnect(u32ClientId);
	return;
}

bool vbox3d::svcbuffer_exists(uint32_t u32ClientId, uint32_t iBuffer, uint32_t cbBufferSize) {
	// if retval == 0, it means that the error returned by 3d accel implied the buffer didn't exist
	uint32_t retval = vbox3d::hgcm_write_buffer_modify(u32ClientId, iBuffer, 0x00, cbBufferSize, NULL, 0);
	return retval != 0;
}

//