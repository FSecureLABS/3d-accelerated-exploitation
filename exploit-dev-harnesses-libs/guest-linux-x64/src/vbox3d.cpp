#include "vbox3d.h"

#include <cstdlib>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <cstdio>

#include "misc.h"

// driver handle
int fd = -1;
// service name
const char svcName[] = "VBoxSharedCrOpenGL\0";

void vbox3d::init() {

    fd = open("/dev/vboxuser", O_RDWR);

    if (fd == -1) {
        bailout("failed to open handle to driver");
    }

}

void vbox3d::destroy() {
#ifdef DEBUG
    LOG_INFO("closing vbox3d environment");
#endif
    close(fd);
}

uint32_t vbox3d::connect() {
    uint32_t u32ClientId = -1, u32OutSize = 4, u32InSize = 132, u32InOutSize = 0;
    void *pConnData = NULL, *pReqBuffer = NULL;
    VBGLREQHDR hdr;

    //
    u32InOutSize = u32OutSize < u32InSize ? u32InSize : u32OutSize; 

    // prepare connection data
    pConnData = calloc(u32InSize, 1);
    ((uint32_t*)pConnData)[0] = VMMDevHGCMLoc_LocalHost_Existing;
    memcpy((char*)pConnData + sizeof(int), svcName, sizeof(svcName));

    // create request header
    hdr = vbox3d::ioctl_header(u32InSize, u32OutSize);

    // create request buffer
    pReqBuffer = calloc(sizeof(hdr) + u32InOutSize, 1);
    memcpy(pReqBuffer, &hdr, sizeof(hdr));
    memcpy((char*)pReqBuffer + sizeof(hdr), pConnData, u32InSize);

    int res = ioctl(fd, VBGL_IOCTL_CODE_SIZE(IOCTL_HGCM_CONNECT, sizeof(hdr) + u32InOutSize), pReqBuffer, 1);

    // just bail if the call failed, since there is something wrong with the code
    // or 3d acceleration is not enabled
    if (res != 0) {
        return 0x00;
    }

    u32ClientId = ((uint32_t*)pReqBuffer)[sizeof(hdr)/sizeof(uint32_t)];
    vbox3d::hgcm_set_version(u32ClientId);

    free(pConnData);
    free(pReqBuffer);
    return u32ClientId;
}

void vbox3d::disconnect(uint32_t u32ClientId) {
    uint32_t u32OutSize = 0, u32InSize = 4, u32InOutSize = 0;
    void *pConnData = NULL, *pReqBuffer = NULL;
    VBGLREQHDR hdr;

    u32InOutSize = u32OutSize < u32InSize ? u32InSize : u32OutSize;

    // prepare connection data
    pConnData = calloc(u32InSize, 1);
    ((uint32_t*)pConnData)[0] = u32ClientId;

    // create request header
    hdr = vbox3d::ioctl_header(u32InSize, u32OutSize);

    // create request buffer
    pReqBuffer = calloc(sizeof(hdr) + u32InOutSize, 1);
    memcpy(pReqBuffer, &hdr, sizeof(hdr));
    memcpy((char*)pReqBuffer + sizeof(hdr), pConnData, u32InSize);

    int res = ioctl(fd, VBGL_IOCTL_CODE_SIZE(IOCTL_HGCM_DISCONNECT, sizeof(hdr) + u32InOutSize), pReqBuffer, 1);

    // just bail if the call failed, since there is something wrong with the code
    // or 3d acceleration is not enabled
    if (res != 0) {
        bailout("vbox3d::disconnect() failed! is 3d acceleration enabled?");
    }
    
    free(pConnData);
    free(pReqBuffer);
}

int vbox3d::hgcm_call(uint32_t u32ClientId, uint32_t u32Function, uint32_t cParms, VBOXHGCMSVCPARM paParms[]) {
    int rc = -1;
    uint32_t u32InOutSize;
    void *pReqBuffer = NULL;
    VBGLIOCHGCMCALL hgcmCall;

    // prepare hgcm call
    u32InOutSize = cParms*sizeof(VBOXHGCMSVCPARM) + sizeof(VBGLIOCHGCMCALL) - sizeof(VBGLREQHDR);

    hgcmCall.Hdr = vbox3d::ioctl_header(u32InOutSize, u32InOutSize);
    hgcmCall.u32ClientID = u32ClientId;
    hgcmCall.u32Function = u32Function;
    hgcmCall.cMsTimeout = 0x41414141;
    hgcmCall.fInterruptible = 0;
    hgcmCall.bReserved = 0;
    hgcmCall.cParms = cParms;

    // create request buffer
    pReqBuffer = calloc(sizeof(VBGLIOCHGCMCALL) + cParms*sizeof(VBOXHGCMSVCPARM), 1);
    memcpy(pReqBuffer, &hgcmCall, sizeof(hgcmCall));
    memcpy((char*)pReqBuffer + sizeof(hgcmCall), (void*)paParms, cParms*sizeof(VBOXHGCMSVCPARM));

    int res = ioctl(fd, VBGL_IOCTL_CODE_SIZE(IOCTL_HGCM_CALL, (sizeof(hgcmCall)-16) + u32InOutSize), pReqBuffer, 1);    

    // just bail if the call failed, since there is something wrong with the code
    // or 3d acceleration is not enabled
    if (res != 0) {
       LOG_ERROR("vbox3d::hgcm_call: failed! is 3d acceleration enabled?");
       LOG_ERROR("vbox3d::hgcm_call: errno => " + to_str(errno) + "; ioctl => " + to_str(res));
    }

    // read rc
    rc = ((int*)pReqBuffer)[3];

    // copy response
    memcpy((void*)paParms, (char*)pReqBuffer + sizeof(hgcmCall), cParms*sizeof(VBOXHGCMSVCPARM));

    free(pReqBuffer);
    return rc;
}

VBGLREQHDR vbox3d::ioctl_header(uint32_t u32InSize, uint32_t u32OutSize) {
    VBGLREQHDR hdr;

    hdr.cbIn = sizeof(VBGLREQHDR) + u32InSize;
    hdr.uVersion = VBGLREQHDR_VERSION;
    hdr.uType = VBGLREQHDR_TYPE_DEFAULT;
    hdr.rc = -225;
    hdr.cbOut = sizeof(VBGLREQHDR) + u32OutSize;
    hdr.uReserved = 0x00;

    return hdr;
}

int vbox3d::hgcm_write(uint32_t u32ClientId, uint8_t* pBuffer, uint32_t cbBuffer) {

	VBOXHGCMSVCPARM paParms[1];
	
	paParms[0].type = VBOX_HGCM_SVC_PARM_PTR;
	paParms[0].u.pointer.addr = pBuffer;
	paParms[0].u.pointer.size = cbBuffer;

	return vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_WRITE, SHCRGL_CPARMS_WRITE, paParms);
}

int vbox3d::hgcm_read(uint32_t u32ClientId, uint8_t* pBuffer, uint32_t cbBuffer) {
	VBOXHGCMSVCPARM paParms[2];

	paParms[0].type = VBOX_HGCM_SVC_PARM_PTR;
	paParms[0].u.pointer.addr = pBuffer;
	paParms[0].u.pointer.size = cbBuffer;

	paParms[1].type = VBOX_HGCM_SVC_PARM_32BIT;

	return vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_READ, SHCRGL_CPARMS_READ, paParms);
}

uint32_t vbox3d::hgcm_write_buffer_create(uint32_t u32ClientId, uint32_t cbBufferSize, uint8_t* pBuffer, uint32_t cbBuffer) {
	uint32_t iBuffer = 0;

	VBOXHGCMSVCPARM paParms[4];

	// paParms[0] - iBuffer
	paParms[0].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[0].u.uint32 = iBuffer; // 0 will force a new allocation
	
	// paParms[1] - cbBufferSize
	paParms[1].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[1].u.uint32 = cbBufferSize;

	// paParms[2] - ui32Offset
	paParms[2].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[2].u.uint32 = 0; // since we are allocating, we copy to the start of the newly-created memory

	// paParms[3] - pBuffer/cbBuffer
	paParms[3].type = VBOX_HGCM_SVC_PARM_PTR;
	paParms[3].u.pointer.addr = pBuffer;
	paParms[3].u.pointer.size = cbBuffer;

	int rc = vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_WRITE_BUFFER, SHCRGL_CPARMS_WRITE_BUFFER, paParms);

	if (rc != 0) {
		return 0;
	}

	iBuffer = paParms[0].u.uint32; // the new iBuffer is written back to us

	return iBuffer;
}

uint32_t vbox3d::hgcm_write_buffer_modify(uint32_t u32ClientId, uint32_t iBuffer, uint32_t ui32Offset,
	uint32_t cbBufferSize, uint8_t* pBuffer, uint32_t cbBuffer) {

	VBOXHGCMSVCPARM paParms[4];

	// paParms[0] - iBuffer
	paParms[0].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[0].u.uint32 = iBuffer;

	// paParms[1] - cbBufferSize
	paParms[1].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[1].u.uint32 = cbBufferSize;

	// paParms[2] - ui32Offset
	paParms[2].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[2].u.uint32 = ui32Offset; // bytes into the buffer we want to start modifying

	// paParms[3] - pBuffer/cbBuffer
	paParms[3].type = VBOX_HGCM_SVC_PARM_PTR;
	paParms[3].u.pointer.addr = pBuffer;
	paParms[3].u.pointer.size = cbBuffer;

	int rc = vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_WRITE_BUFFER, SHCRGL_CPARMS_WRITE_BUFFER, paParms);

	if (rc != 0) {
		return 0;
	}

	iBuffer = paParms[0].u.uint32; // the new iBuffer is written back to us

	return iBuffer;
}

uint32_t vbox3d::hgcm_read_buffered(uint32_t u32ClientId, uint32_t iBuffer, uint8_t* pWriteback, uint32_t cbWriteback) {
	
	VBOXHGCMSVCPARM paParms[3];

	// paParms[0] - iBuffer
	paParms[0].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[0].u.uint32 = iBuffer;

	// paParms[1] - pWriteback/cbWriteback
	paParms[1].type = VBOX_HGCM_SVC_PARM_PTR;
	paParms[1].u.pointer.addr = pWriteback;
	paParms[1].u.pointer.size = cbWriteback;

	// paParms[2] - cbWriteback
	// written size writeback
	paParms[2].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[2].u.uint32 = 0;

	int rc = vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, SHCRGL_CPARMS_WRITE_READ_BUFFERED, paParms);

	if (rc != 0) {
	}

	return paParms[2].u.uint32;
}

int vbox3d::hgcm_set_version(uint32_t u32ClientId) {
	VBOXHGCMSVCPARM paParms[2];

    memset((void*)paParms, 0x00, 2*sizeof(VBOXHGCMSVCPARM));

	// vMajor
	paParms[0].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[0].u.uint32 = CR_PROTOCOL_VERSION_MAJOR;

	// vMinor
	paParms[1].type = VBOX_HGCM_SVC_PARM_32BIT;
	paParms[1].u.uint32 = CR_PROTOCOL_VERSION_MINOR;

	return vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_SET_VERSION, SHCRGL_CPARMS_SET_VERSION, paParms);
}

int vbox3d::hgcm_set_pid(uint32_t u32ClientId, int64_t pid) {

	VBOXHGCMSVCPARM paParms[1];
	
	// pid
	paParms[0].type = VBOX_HGCM_SVC_PARM_64BIT;
	paParms[0].u.uint64 = pid;

	return vbox3d::hgcm_call(u32ClientId, SHCRGL_GUEST_FN_SET_PID, SHCRGL_CPARMS_SET_PID, paParms);
}

bool vbox3d::svcbuffer_exists(uint32_t u32ClientId, uint32_t iBuffer, uint32_t cbBufferSize) {
	// if retval == 0, it means that the error returned by 3d accel implied the buffer didn't exist
	uint32_t retval = vbox3d::hgcm_write_buffer_modify(u32ClientId, iBuffer, 0x00, cbBufferSize, NULL, 0);
	return retval != 0;
}
