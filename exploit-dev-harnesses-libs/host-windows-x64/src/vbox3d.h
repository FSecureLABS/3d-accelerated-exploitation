#pragma once
#include <direct.h>
#include <Windows.h>
#include "misc.h"
#include "hgcmsvc.h"

// VBOXHGCMSVCFNTABLE
#define VBOXHGCMSVCFNTABLE_SIZE					0x60 // 0x70 on VBox 6 prod
#define VBOXHGCMSVCFNTABLE_CBSIZE_OFFSET		0x00
#define VBOXHGCMSVCFNTABLE_U32VERSION_OFFSET	0x04
#define VBOXHGCMSVCFNTABLE_PHELPERS_OFFSET		0x08
#define VBOXHGCMSVCFNTABLE_SVCCALL_OFFSET		0x30

// some datatypes
typedef unsigned int uint32_t;
typedef unsigned char uint8_t;

// CR version
#define CR_PROTOCOL_VERSION_MAJOR 9
#define CR_PROTOCOL_VERSION_MINOR 1

// HGCMSVC Version
#define VBOX_HGCM_SVC_VERSION_MAJOR (0x0005)
#define VBOX_HGCM_SVC_VERSION_MINOR (0x0001)
#define VBOX_HGCM_SVC_VERSION ((VBOX_HGCM_SVC_VERSION_MAJOR << 16) + VBOX_HGCM_SVC_VERSION_MINOR)

/** Service helpers pointers table. */
typedef struct VBOXHGCMSVCHELPERS
{
	void(*pfnCallComplete)(void*, int32_t rc);
	void *pvInstance;
	void(*pfnDisconnectClient)(void*, uint32_t u32ClientId);
} VBOXHGCMSVCHELPERS;

typedef VBOXHGCMSVCHELPERS *PVBOXHGCMSVCHELPERS;

// exported methods
typedef int( *_VBoxHGCMSvcLoad)(void*);
typedef void(__cdecl *_svcCall)(void*, int, uint32_t u32ClientId, void*, uint32_t u32Function, uint32_t cParms, VBOXHGCMSVCPARM paParms[]);

typedef uint32_t(*_crVBoxServerAddClient)(uint32_t u32ClientId);
typedef void(*_crVBoxServerRemoveClient)(uint32_t u32ClientId);


#define GET_PROC_ADDR(type, hModule, lpProcName) (type)GetProcAddress(hModule, lpProcName);

namespace vbox3d {
	/// environment setup
	void init();
	void destroy();
	void pfnCallComplete(void*, int32_t rc);
	void pfnDisconnectClient(void*, uint32_t u32ClientId);

	/// main
	uint32_t connect();
	void disconnect(uint32_t u32ClientId);
	int hgcm_call(uint32_t u32ClientId, uint32_t u32Function, uint32_t cParms, VBOXHGCMSVCPARM paParms[]);

	/// function wrappers
	
	// SHCRGL_GUEST_FN_WRITE
	int hgcm_write(uint32_t u32ClientId, uint8_t* pBuffer, uint32_t cbBuffer);
	
	// SHCRGL_GUEST_FN_READ
	int hgcm_read(uint32_t u32ClientId, uint8_t* pBuffer, uint32_t cbBuffer);
	
	// SHCRGL_GUEST_FN_WRITE_BUFFER
	uint32_t hgcm_write_buffer_create(uint32_t u32ClientId, uint32_t cbBufferSize, uint8_t* pBuffer, uint32_t cbBuffer);
	uint32_t hgcm_write_buffer_modify(uint32_t u32ClientId, uint32_t iBuffer, uint32_t ui32Offset,
		uint32_t cbBufferSize, uint8_t* pBuffer, uint32_t cbBuffer);
	
	// SHCRGL_GUEST_FN_WRITE_READ_BUFFERED
	uint32_t hgcm_read_buffered(uint32_t u32ClientId, uint32_t iBuffer, uint8_t* pWriteback, uint32_t cbWriteback);
	
	// SHCRGL_GUEST_FN_SET_VERSION
	int hgcm_set_version(uint32_t u32ClientId);
	
	// SHCRGL_GUEST_FN_SET_PID
	int hgcm_set_pid(uint32_t u32ClientId, int64_t pid);

	/// helpers
	bool svcbuffer_exists(uint32_t u32ClientId, uint32_t iBuffer, uint32_t cbBufferSize);
}
