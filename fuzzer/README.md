# AFL Fuzzer for 3D Acceleration

Fuzzing 3D acceleration should ideally mean isolating the core components of the actual attack surface, and passing input to that. This means spinnig up a virtual machine and sending a bunch of Chromium messages just isn't as convenient as attempting to do it without VirtualBox.

This section of the repository contains information on how to compile VirtualBox with AFL, and what an example fuzzing harness might look like.

## building VirtualBox with AFL

The build process is very straight forward. Specifying `afl-gcc` and `afl-g++` when running the `configure` script was sufficient, and no compilation errors were observed as a result of this. However, your mileage may vary.

```
$ CC=afl-gcc CXX=afl-g++ ./configure --disable-hardening
$ kmk BUILD_TYPE=debug
```

However, it should be noted that a debug build will result in a log file being created, and written to, each time the fuzzing harness is launched. This isn't great, as one tends to run out of disk space very quickly. This can be avoided by modifying `src/VBox/Runtime/VBox/log-vbox.cpp`.

```cpp
...
 rc = -1; // RTLogCreate(...);
...
```

Commenting out the first call to `RTLogCreate`, and making the value of `rc` equal to -1 tells 3D acceleration that the log creation failed and shouldn't do it.

Example of what life was like before modifying the code:

```
*/1 * * * * rm -rf /.../harness/bin/2018-*
*/1 * * * * sleep 20 && rm -rf /.../harness/bin/2018-*
*/1 * * * * sleep 40 && rm -rf /.../harness/bin/2018-*
```

## fuzzing harness

An example fuzzer is provided (defined in `fuzzers.h`), which 

The following libraries from the build are required to run the compiled harness:

* VBoxSharedCrOpenGL.so
* VBoxOGLhostcrutil.so
* VBoxOGLrenderspu.so
* VBoxREM.so
* VBoxRT.so
* VBoxVMM.so
* VBoxXPCOM.so